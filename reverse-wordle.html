<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse Wordle</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 80px;
            background-color: #121213;
            color: white;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            color: white;
        }
        
        .instructions {
            text-align: center;
            margin-bottom: 20px;
            color: #818384;
            line-height: 1.4;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-board {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            gap: 5px;
            margin-bottom: 20px;
        }
        
        .guess-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
        }
        
        .letter-tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #3a3a3c;
            background-color: #121213;
            color: white;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .letter-tile:hover {
            transform: scale(1.05);
        }
        
        .letter-tile.clickable {
            cursor: pointer;
        }
        
        .letter-tile.clickable:hover {
            border-color: #818384;
        }
        
        .letter-tile.correct {
            background-color: #538d4e;
            border-color: #538d4e;
        }
        
        .letter-tile.wrong-position {
            background-color: #b59f3b;
            border-color: #b59f3b;
        }
        
        .letter-tile.not-in-word {
            background-color: #3a3a3c;
            border-color: #3a3a3c;
        }
        
        /* Removed legacy bottom grading UI styles */
        
        
        /* end removed styles */
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .button-row {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #818384;
            color: white;
        }
        
        button:hover {
            background-color: #565758;
        }
        
        button:disabled {
            background-color: #3a3a3c;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 15px;
            min-height: 25px;
        }
        
        .won {
            color: #538d4e;
        }
        
        .lost {
            color: #f5793a;
        }
    </style>
    <script src="words.js"></script>
</head>
<body>
    <h1>Reverse Wordle</h1>
    
    <div class="instructions">
        Think of a 5-letter word. The computer will try to guess it!<br>
        After each guess, click each tile to cycle colors: Gray → Green → Yellow. Set all five to match Wordle’s result, then click “Submit Feedback”. Use “Undo Last Guess” if a grading mistake was made.
    </div>
    
    <div class="game-container">
        <div class="status" id="status">Click "Start Game" to begin!</div>
        
        <div class="game-board" id="gameBoard">
            <!-- Game board will be populated by JavaScript -->
        </div>
        
        <div class="control-buttons">
            <div class="button-row" id="gameButtons" style="display: none;">
                <button id="submitButton" onclick="submitFeedback()" disabled>Submit</button>
                <button id="undoButton" onclick="undoLastGuess()" disabled>Undo</button>
            </div>
            <div class="button-row">
                <button onclick="startGame()">Start</button>
                <button onclick="resetGame()">Reset</button>
            </div>
        </div>
    </div>
    

    <script>
        // Game state
        let gameActive = false;
        let currentGuess = 0;
        let currentWord = '';
        let possibleWords = [];
        let usedWords = [];
        let gameWon = false;
        
        // Undo state tracking
        let gameStateHistory = [];
        
        
        // Initialize game board
        function initializeBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'guess-row';
                row.id = `row-${i}`;
                
                for (let j = 0; j < 5; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'letter-tile';
                    tile.id = `tile-${i}-${j}`;
                    row.appendChild(tile);
                }
                
                board.appendChild(row);
            }
        }
        
        // Start new game
        function startGame() {
            gameActive = true;
            currentGuess = 0;
            gameWon = false;
            possibleWords = [...WORD_LIST];
            usedWords = [];
            gameStateHistory = [];
            
            initializeBoard();
            document.getElementById('status').textContent = 'Think of a word, then click to see my guess!';
            
            // Show game buttons
            document.getElementById('gameButtons').style.display = 'flex';
            
            updateUndoButton();
            updateSubmitButton();
            
            makeGuess();
        }
        
        // Reset game
        function resetGame() {
            gameActive = false;
            currentGuess = 0;
            gameWon = false;
            possibleWords = [];
            usedWords = [];
            currentWord = '';
            gameStateHistory = [];
            
            initializeBoard();
            document.getElementById('status').textContent = 'Click "Start Game" to begin!';
            
            // Hide game buttons
            document.getElementById('gameButtons').style.display = 'none';
            
            updateUndoButton();
            updateSubmitButton();
        }
        
        // Save current game state for undo functionality
        function saveGameState() {
            const state = {
                gameActive: gameActive,
                currentGuess: currentGuess,
                currentWord: currentWord,
                possibleWords: [...possibleWords],
                usedWords: [...usedWords],
                gameWon: gameWon,
                boardState: getBoardState()
            };
            gameStateHistory.push(state);
            updateUndoButton();
        }
        
        // Get current board state for restoration
        function getBoardState() {
            const state = [];
            for (let row = 0; row < 6; row++) {
                const rowState = [];
                for (let col = 0; col < 5; col++) {
                    const tile = document.getElementById(`tile-${row}-${col}`);
                    if (tile) {
                        rowState.push({
                            letter: tile.textContent,
                            classes: tile.className
                        });
                    }
                }
                state.push(rowState);
            }
            return state;
        }
        
        // Restore board state
        function restoreBoardState(boardState) {
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 5; col++) {
                    const tile = document.getElementById(`tile-${row}-${col}`);
                    if (tile && boardState[row] && boardState[row][col]) {
                        tile.textContent = boardState[row][col].letter;
                        tile.className = boardState[row][col].classes;
                    }
                }
            }
        }
        
        // Undo last guess
        function undoLastGuess() {
            if (gameStateHistory.length === 0) return;
            
            const previousState = gameStateHistory.pop();
            
            // Restore all game state variables
            gameActive = previousState.gameActive;
            currentGuess = previousState.currentGuess;
            currentWord = previousState.currentWord;
            possibleWords = [...previousState.possibleWords];
            usedWords = [...previousState.usedWords];
            gameWon = previousState.gameWon;
            
            // Restore board visual state
            restoreBoardState(previousState.boardState);
            
            // If there's a current word (meaning we can undo), make tiles clickable again
            if (currentWord && gameActive) {
                // Reset feedback data
                feedbackData = [];
                
                // Make the tiles for the current guess clickable again
                // Remove feedback colors and add clickable functionality
                for (let i = 0; i < 5; i++) {
                    const tile = document.getElementById(`tile-${currentGuess}-${i}`);
                    if (tile) {
                        // Remove all feedback colors but keep the letter
                        tile.classList.remove('correct', 'wrong-position', 'not-in-word');
                        // Add clickable functionality with default gray
                        tile.classList.add('clickable', 'not-in-word');
                        tile.onclick = () => cycleTileFeedback(currentGuess, i);
                        // Set default feedback to gray
                        feedbackData[i] = 'not-in-word';
                    }
                }
                
                // Update status to show current guess
                const availableWords = possibleWords.filter(word => !usedWords.includes(word));
                document.getElementById('status').textContent = `My guess is: ${currentWord} (${availableWords.length} possibilities left)`;
            } else {
                // Update status message
                if (currentGuess === 0) {
                    document.getElementById('status').textContent = 'Think of a word, then click to see my guess!';
                } else {
                    document.getElementById('status').textContent = 'Click to continue...';
                }
            }
            
            updateUndoButton();
            updateSubmitButton();
        }
        
        // Update undo button state
        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            undoButton.disabled = gameStateHistory.length === 0 || !gameActive;
        }
        
        // Calculate entropy of a guess - how much information it provides
        function calculateEntropy(guess, candidateWords) {
            if (candidateWords.length <= 1) return 0;
            
            const feedbackGroups = {};
            
            // Group candidate words by the feedback pattern they would give
            for (const word of candidateWords) {
                const feedback = getFeedbackPattern(word, guess);
                const key = feedback.join('');
                if (!feedbackGroups[key]) feedbackGroups[key] = 0;
                feedbackGroups[key]++;
            }
            
            // Calculate entropy: sum of -p * log2(p) for each group
            let entropy = 0;
            const total = candidateWords.length;
            for (const count of Object.values(feedbackGroups)) {
                const probability = count / total;
                entropy -= probability * Math.log2(probability);
            }
            
            return entropy;
        }
        
        // Get feedback pattern for a guess against a target word
        function getFeedbackPattern(targetWord, guess) {
            const feedback = new Array(5).fill('not-in-word');
            const targetLetters = targetWord.split('');
            const guessLetters = guess.split('');
            const usedTargetIndices = new Set();
            
            // First pass: mark correct positions
            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] === targetLetters[i]) {
                    feedback[i] = 'correct';
                    usedTargetIndices.add(i);
                }
            }
            
            // Second pass: mark wrong positions
            for (let i = 0; i < 5; i++) {
                if (feedback[i] === 'not-in-word') {
                    for (let j = 0; j < 5; j++) {
                        if (!usedTargetIndices.has(j) && guessLetters[i] === targetLetters[j]) {
                            feedback[i] = 'wrong-position';
                            usedTargetIndices.add(j);
                            break;
                        }
                    }
                }
            }
            
            return feedback;
        }
        
        // Find the best guess using information theory (optimized for performance)
        function findBestGuess(candidateWords) {
            if (candidateWords.length === 0) return null;
            if (candidateWords.length === 1 && !usedWords.includes(candidateWords[0])) {
                return candidateWords[0];
            }
            
            let bestGuess = null;
            let maxEntropy = -1;
            
            // PERFORMANCE OPTIMIZATION: Limit search space based on remaining candidates
            let potentialGuesses;
            
            if (candidateWords.length > 100) {
                // Many candidates left: use a strategic subset for guessing
                potentialGuesses = [...new Set([
                    ...candidateWords.slice(0, 50), // First 50 candidates
                    ...getCommonWords().filter(w => !usedWords.includes(w)) // Common words
                ])];
            } else if (candidateWords.length > 20) {
                // Moderate candidates: use candidates + common words
                potentialGuesses = [...new Set([
                    ...candidateWords,
                    ...getCommonWords().filter(w => !usedWords.includes(w))
                ])];
            } else {
                // Few candidates: consider more options but still limited
                potentialGuesses = [...new Set([
                    ...candidateWords,
                    ...getCommonWords().filter(w => !usedWords.includes(w)),
                    ...WORD_LIST.slice(0, 100).filter(w => !usedWords.includes(w))
                ])];
            }
            
            // Further limit to prevent browser freeze
            potentialGuesses = potentialGuesses.slice(0, 100);
            
            for (const guess of potentialGuesses) {
                if (usedWords.includes(guess)) continue;
                
                const entropy = calculateEntropy(guess, candidateWords);
                
                // Prefer guesses that are also possible answers (strong tie-breaker)
                const isCandidate = candidateWords.includes(guess);
                const score = entropy + (isCandidate ? 1.0 : 0);
                
                if (score > maxEntropy) {
                    maxEntropy = score;
                    bestGuess = guess;
                }
            }
            
            return bestGuess;
        }
        
        // Get common words for better first guesses
        function getCommonWords() {
            return ['AROSE', 'ADIEU', 'AUDIO', 'LOUIE', 'OUIJA', 'RAISE', 'SLATE', 'CRANE', 'TRACE', 'CRATE'];
        }
        
        // Get the best 100 starting words for random selection
        function getBestStartingWords() {
            return [
                'AROSE', 'ADIEU', 'AUDIO', 'LOUIE', 'OUIJA', 'RAISE', 'SLATE', 'CRANE', 'TRACE', 'CRATE',
                'SLANT', 'STARE', 'LEAST', 'SNARE', 'TALES', 'TEARS', 'RATES', 'TARES', 'CARES', 'RACES',
                'STALE', 'SNARL', 'STERN', 'STONE', 'STORE', 'HORSE', 'SHORE', 'THOSE', 'HOUSE', 'MOUSE',
                'NOISE', 'POISE', 'PROSE', 'TONES', 'BONES', 'CONES', 'NODES', 'ROPES', 'HOPES', 'MOPES',
                'NOTES', 'VOTES', 'SIREN', 'OILER', 'ALINE', 'ALIEN', 'SNEAK', 'SNAKE', 'STAKE', 'SHAKE',
                'SHAPE', 'SHADE', 'SHARE', 'SPARE', 'SPACE', 'PLACE', 'PLANE', 'PLATE', 'BRAVE', 'GRAVE',
                'GRACE', 'FRAME', 'FLAME', 'BLAME', 'CLAMP', 'CHAMP', 'STAMP', 'STOMP', 'STUMP', 'SLUMP',
                'STEAM', 'STEAD', 'STEAL', 'STEAK', 'SPEAK', 'SPEAR', 'SMEAR', 'CLEAR', 'CLEAN', 'BEACH',
                'TEACH', 'REACH', 'PEACH', 'PEACE', 'PHASE', 'CHASE', 'CHOSE', 'CLOSE', 'CLONE', 'ALONE',
                'STONE', 'SCORE', 'STORE', 'SHORE', 'SHONE', 'PHONE', 'PRONE', 'DRONE', 'CRONE', 'GRIME'
            ];
        }
        
        // Make a guess using advanced strategy
        function makeGuess() {
            if (!gameActive || currentGuess >= 6) return;
            
            let guess = null;
            
            // Filter out already used words
            const availableWords = possibleWords.filter(word => !usedWords.includes(word));
            
            console.log(`[DEBUG] === MAKING GUESS ${currentGuess + 1} ===`);
            console.log(`[DEBUG] Possible words: ${possibleWords.length} (${possibleWords.slice(0, 5).join(', ')}${possibleWords.length > 5 ? '...' : ''})`);
            console.log(`[DEBUG] Used words: ${usedWords.join(', ')}`);
            console.log(`[DEBUG] Available words: ${availableWords.length} (${availableWords.join(', ')})`);
            
            if (currentGuess === 0) {
                // First guess: randomly select from best starting words
                const bestStartingWords = getBestStartingWords();
                const availableStartingWords = bestStartingWords.filter(word => !usedWords.includes(word));
                guess = availableStartingWords[Math.floor(Math.random() * availableStartingWords.length)];
                console.log(`[DEBUG] Branch: First guess (random from ${availableStartingWords.length} options) -> ${guess}`);
            } else if (availableWords.length === 1) {
                // Only one option left
                guess = availableWords[0];
                console.log(`[DEBUG] Branch: Only one option left -> ${guess}`);
            } else if (availableWords.length > 0) {
                // Use information theory to find best guess
                guess = findBestGuess(availableWords);
                console.log(`[DEBUG] Branch: Information theory -> ${guess}`);
            } else {
                console.log(`[DEBUG] Branch: No available words - triggering fallback!`);
            }
            
            // Final fallback: pick any unused word from the entire dictionary
            if (!guess || usedWords.includes(guess)) {
                console.log(`[DEBUG] 🚨 FALLBACK TRIGGERED! guess=${guess}, already used=${usedWords.includes(guess)}`);
                const unusedWords = WORD_LIST.filter(word => !usedWords.includes(word));
                console.log(`[DEBUG] Unused words: ${unusedWords.length} available`);
                if (unusedWords.length > 0) {
                    // Prefer common words first
                    const unusedCommon = getCommonWords().filter(word => !usedWords.includes(word));
                    console.log(`[DEBUG] Unused common words: ${unusedCommon.join(', ')}`);
                    guess = unusedCommon[0] || unusedWords[0];
                    console.log(`[DEBUG] Fallback selected: ${guess}`);
                } else {
                    // This should never happen with our large word list
                    guess = 'ERROR';
                }
            }
            
            // Safety check to prevent repeats
            if (usedWords.includes(guess)) {
                console.error('Attempting to repeat guess:', guess);
                const backup = WORD_LIST.find(word => !usedWords.includes(word));
                guess = backup || 'ERROR';
            }
            
            // Add to used words to prevent repetition
            usedWords.push(guess);
            currentWord = guess;
            displayGuess(guess, currentGuess);
            updateSubmitButton();
            
            // Show additional info for debugging
            const remaining = availableWords.length;
            console.log(`Turn ${currentGuess + 1}: Guessing ${guess}, ${remaining} possibilities left`);
            console.log('Remaining possibilities:', availableWords.slice(0, 10).join(', ') + (availableWords.length > 10 ? '...' : ''));
            document.getElementById('status').textContent = `My guess is: ${guess} (${remaining} possibilities left)`;
        }
        
        // Display the guess on the board
        function displayGuess(word, row) {
            for (let i = 0; i < 5; i++) {
                const tile = document.getElementById(`tile-${row}-${i}`);
                tile.textContent = word[i];
                
                // Make tiles clickable for current guess only
                if (row === currentGuess) {
                    tile.classList.add('clickable', 'not-in-word');
                    tile.onclick = () => cycleTileFeedback(row, i);
                    // Set default feedback to gray
                    feedbackData[i] = 'not-in-word';
                } else {
                    tile.classList.remove('clickable');
                    tile.onclick = null;
                }
            }
        }
        
        // Track feedback selections
        let feedbackData = [];
        
        // Cycle through feedback colors when clicking a tile
        function cycleTileFeedback(row, col) {
            if (row !== currentGuess || !gameActive) return;
            
            const tile = document.getElementById(`tile-${row}-${col}`);
            const currentClasses = tile.className;
            
            // Cycle through: gray -> green -> yellow -> gray
            if (currentClasses.includes('not-in-word')) {
                tile.className = 'letter-tile clickable correct';
                feedbackData[col] = 'correct';
            } else if (currentClasses.includes('correct')) {
                tile.className = 'letter-tile clickable wrong-position';
                feedbackData[col] = 'wrong-position';
            } else if (currentClasses.includes('wrong-position')) {
                tile.className = 'letter-tile clickable not-in-word';
                feedbackData[col] = 'not-in-word';
            }
        }
        
        // Submit feedback and continue game
        function submitFeedback() {
            // Check if all 5 positions have feedback (no undefined values)
            let missingFeedback = 0;
            for (let i = 0; i < 5; i++) {
                if (feedbackData[i] === undefined) {
                    missingFeedback++;
                }
            }
            
            if (missingFeedback > 0) {
                alert(`Please mark all 5 letters! (${missingFeedback} letters still need feedback)`);
                return;
            }
            
            // Apply feedback to the board
            for (let i = 0; i < 5; i++) {
                const tile = document.getElementById(`tile-${currentGuess}-${i}`);
                tile.classList.add(feedbackData[i]);
            }
            
            // Check if won
            if (feedbackData.every(f => f === 'correct')) {
                gameWon = true;
                gameActive = false;
                document.getElementById('status').innerHTML = '<span class="won">I got it! 🎉</span>';
                updateSubmitButton();
                return;
            }
            
            // Save current state before making changes (for undo functionality)
            saveGameState();
            
            // Filter possible words based on feedback
            filterPossibleWords();
            
            // Move to next guess
            currentGuess++;
            feedbackData = [];
            updateSubmitButton();
            
            if (currentGuess >= 6) {
                gameActive = false;
                document.getElementById('status').innerHTML = '<span class="lost">I give up! What was your word?</span>';
            } else {
                setTimeout(() => makeGuess(), 500);
            }
        }
        
        // Filter possible words based on feedback
        function filterPossibleWords() {
            console.log(`[DEBUG] Before filtering: ${possibleWords.length} words`);
            console.log(`[DEBUG] Current word: ${currentWord}, Feedback: ${feedbackData.join(',')}`);
            console.log(`[DEBUG] Possible words before: ${possibleWords.slice(0, 10).join(', ')}${possibleWords.length > 10 ? '...' : ''}`);
            
            possibleWords = possibleWords.filter(word => {
                const possible = isWordPossible(word, currentWord, feedbackData);
                if (!possible && (word === 'KNELL' || word === 'KNELT')) {
                    console.log(`[DEBUG] ❌ ${word} eliminated by ${currentWord} with feedback ${feedbackData.join(',')}`);
                }
                return possible;
            });
            
            console.log(`[DEBUG] After filtering: ${possibleWords.length} words`);
            console.log(`[DEBUG] Remaining words: ${possibleWords.slice(0, 10).join(', ')}${possibleWords.length > 10 ? '...' : ''}`);
        }
        
        // Check if a word is possible given the guess and feedback
        function isWordPossible(word, guess, feedback) {
            // Count letter occurrences in guess with different feedback types
            const letterFeedback = {};
            
            for (let i = 0; i < 5; i++) {
                const letter = guess[i];
                if (!letterFeedback[letter]) {
                    letterFeedback[letter] = {correct: [], wrongPosition: [], notInWord: []};
                }
                letterFeedback[letter][feedback[i] === 'correct' ? 'correct' : 
                                     feedback[i] === 'wrong-position' ? 'wrongPosition' : 'notInWord'].push(i);
            }
            
            // Check each letter constraint
            for (const [letter, constraints] of Object.entries(letterFeedback)) {
                // Check correct positions
                for (const pos of constraints.correct) {
                    if (word[pos] !== letter) return false;
                }
                
                // Check wrong positions
                for (const pos of constraints.wrongPosition) {
                    if (word[pos] === letter) return false; // Letter shouldn't be in this position
                    if (!word.includes(letter)) return false; // But word must contain this letter
                }
                
                // Check not-in-word only if letter doesn't appear as correct or wrong-position
                if (constraints.notInWord.length > 0 && 
                    constraints.correct.length === 0 && 
                    constraints.wrongPosition.length === 0) {
                    if (word.includes(letter)) return false;
                }
                
                // Handle mixed feedback for same letter
                if (constraints.correct.length > 0 || constraints.wrongPosition.length > 0) {
                    const expectedCount = constraints.correct.length + constraints.wrongPosition.length;
                    const actualCount = (word.match(new RegExp(letter, 'g')) || []).length;
                    
                    // If some instances are marked "not-in-word", the word should have exactly the expected count
                    // UNLESS the word has more instances that could be in valid positions
                    if (constraints.notInWord.length > 0) {
                        // Check if extra letters are in positions not marked as "not-in-word"
                        const notInWordPositions = new Set(constraints.notInWord);
                        let validExtraCount = 0;
                        
                        for (let i = 0; i < word.length; i++) {
                            if (word[i] === letter && !notInWordPositions.has(i) && 
                                !constraints.correct.includes(i) && !constraints.wrongPosition.includes(i)) {
                                validExtraCount++;
                            }
                        }
                        
                        if (actualCount > expectedCount + validExtraCount) {
                            return false;
                        }
                        if (actualCount < expectedCount) {
                            return false;
                        }
                    } else {
                        // If no instances are marked "not-in-word", the word should have at least the expected count
                        if (actualCount < expectedCount) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Enable/disable submit based on game state
        function updateSubmitButton() {
            const btn = document.getElementById('submitButton');
            if (!btn) return;
            const canSubmit = gameActive && currentWord && currentGuess < 6;
            btn.disabled = !canSubmit;
        }

        // Initialize the game
        initializeBoard();
    </script>
</body>
</html>
